"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOriginURL = exports.isHttpSubsegment = exports.findHeaderAndDecode = void 0;
const node_url_1 = require("node:url");
const decoder = new TextDecoder();
/**
 * The `fetch` implementation based on `undici` includes the headers as an array of encoded key-value pairs.
 * This function finds the header with the given key and decodes the value.
 *
 * The function walks through the array of encoded headers and decodes the key of each pair.
 * If the key matches the given key, the function returns the decoded value of the next element in the array.
 *
 * @param encodedHeaders The array of encoded headers
 * @param key The key to search for
 */
const findHeaderAndDecode = (encodedHeaders, key) => {
    let foundIndex = -1;
    for (let i = 0; i < encodedHeaders.length; i += 2) {
        const header = decoder.decode(encodedHeaders[i]);
        if (header.toLowerCase() === key) {
            foundIndex = i;
            break;
        }
    }
    if (foundIndex === -1) {
        return null;
    }
    return decoder.decode(encodedHeaders[foundIndex + 1]);
};
exports.findHeaderAndDecode = findHeaderAndDecode;
/**
 * Type guard to check if the given subsegment is an `HttpSubsegment`
 *
 * @param subsegment The subsegment to check
 */
const isHttpSubsegment = (subsegment) => {
    return (subsegment !== undefined &&
        'http' in subsegment &&
        'parent' in subsegment &&
        'namespace' in subsegment &&
        subsegment.namespace === 'remote');
};
exports.isHttpSubsegment = isHttpSubsegment;
/**
 * Convert the origin url to a URL object when it is a string
 *
 * @param origin The origin url
 */
const getOriginURL = (origin) => {
    return origin instanceof node_url_1.URL ? origin : new node_url_1.URL(origin);
};
exports.getOriginURL = getOriginURL;
